diff --git a/dist/vanilla-extract-integration.cjs.dev.js b/dist/vanilla-extract-integration.cjs.dev.js
index 0f5bec6b6c772fdbd76f06662642faf745ed4f6e..c80e0f941e3517edb7319fb9f655e78d81e90489 100644
--- a/dist/vanilla-extract-integration.cjs.dev.js
+++ b/dist/vanilla-extract-integration.cjs.dev.js
@@ -1,37 +1,47 @@
-'use strict';
+"use strict";
 
-Object.defineProperty(exports, '__esModule', { value: true });
+Object.defineProperty(exports, "__esModule", { value: true });
 
-var transformCss = require('@vanilla-extract/css/transformCss');
-var evalCode = require('eval');
-var javascriptStringify = require('javascript-stringify');
-var isPlainObject = require('lodash/isPlainObject');
-var outdent = require('outdent');
-var crypto = require('crypto');
-var zlib = require('zlib');
-var util = require('util');
-var path = require('path');
-var findUp = require('find-up');
-var fs = require('fs');
-var esbuild = require('esbuild');
-var babel = require('@babel/core');
-var vanillaBabelPlugin = require('@vanilla-extract/babel-plugin-debug-ids');
-var typescriptSyntax = require('@babel/plugin-syntax-typescript');
-var mlly = require('mlly');
+var transformCss = require("@vanilla-extract/css/transformCss");
+var evalCode = require("eval");
+var javascriptStringify = require("javascript-stringify");
+var isPlainObject = require("lodash/isPlainObject");
+var outdent = require("outdent");
+var crypto = require("crypto");
+var zlib = require("zlib");
+var util = require("util");
+var path = require("path");
+var findUp = require("find-up");
+var fs = require("fs");
+var esbuild = require("esbuild");
+var babel = require("@babel/core");
+var vanillaBabelPlugin = require("@vanilla-extract/babel-plugin-debug-ids");
+var typescriptSyntax = require("@babel/plugin-syntax-typescript");
+var mlly = require("mlly");
 
-function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }
+function _interopDefault(e) {
+  return e && e.__esModule ? e : { default: e };
+}
 
 function _interopNamespace(e) {
   if (e && e.__esModule) return e;
   var n = Object.create(null);
   if (e) {
     Object.keys(e).forEach(function (k) {
-      if (k !== 'default') {
+      if (k !== "default") {
         var d = Object.getOwnPropertyDescriptor(e, k);
-        Object.defineProperty(n, k, d.get ? d : {
-          enumerable: true,
-          get: function () { return e[k]; }
-        });
+        Object.defineProperty(
+          n,
+          k,
+          d.get
+            ? d
+            : {
+                enumerable: true,
+                get: function () {
+                  return e[k];
+                },
+              },
+        );
       }
     });
   }
@@ -39,59 +49,60 @@ function _interopNamespace(e) {
   return Object.freeze(n);
 }
 
-var evalCode__default = /*#__PURE__*/_interopDefault(evalCode);
-var isPlainObject__default = /*#__PURE__*/_interopDefault(isPlainObject);
-var outdent__default = /*#__PURE__*/_interopDefault(outdent);
-var crypto__default = /*#__PURE__*/_interopDefault(crypto);
-var path__default = /*#__PURE__*/_interopDefault(path);
-var findUp__default = /*#__PURE__*/_interopDefault(findUp);
-var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
-var vanillaBabelPlugin__default = /*#__PURE__*/_interopDefault(vanillaBabelPlugin);
-var typescriptSyntax__default = /*#__PURE__*/_interopDefault(typescriptSyntax);
+var evalCode__default = /*#__PURE__*/ _interopDefault(evalCode);
+var isPlainObject__default = /*#__PURE__*/ _interopDefault(isPlainObject);
+var outdent__default = /*#__PURE__*/ _interopDefault(outdent);
+var crypto__default = /*#__PURE__*/ _interopDefault(crypto);
+var path__default = /*#__PURE__*/ _interopDefault(path);
+var findUp__default = /*#__PURE__*/ _interopDefault(findUp);
+var babel__namespace = /*#__PURE__*/ _interopNamespace(babel);
+var vanillaBabelPlugin__default =
+  /*#__PURE__*/ _interopDefault(vanillaBabelPlugin);
+var typescriptSyntax__default = /*#__PURE__*/ _interopDefault(typescriptSyntax);
 
-const hash = value => crypto__default["default"].createHash('md5').update(value).digest('hex');
+const hash = (value) =>
+  crypto__default["default"].createHash("md5").update(value).digest("hex");
 
 const zip = util.promisify(zlib.gzip);
 const unzip = util.promisify(zlib.gunzip);
 
 // The byte threshold for applying compression, below which compressing would out-weigh its value.
 const compressionThreshold = 1000;
-const compressionFlag = '#';
+const compressionFlag = "#";
 async function serializeCss(source) {
   if (source.length > compressionThreshold) {
     const compressedSource = await zip(source);
-    return compressionFlag + compressedSource.toString('base64');
+    return compressionFlag + compressedSource.toString("base64");
   }
-  return Buffer.from(source, 'utf-8').toString('base64');
+  return Buffer.from(source, "utf-8").toString("base64");
 }
 async function deserializeCss(source) {
   if (source.indexOf(compressionFlag) > -1) {
-    const decompressedSource = await unzip(Buffer.from(source.replace(compressionFlag, ''), 'base64'));
-    return decompressedSource.toString('utf-8');
+    const decompressedSource = await unzip(
+      Buffer.from(source.replace(compressionFlag, ""), "base64"),
+    );
+    return decompressedSource.toString("utf-8");
   }
-  return Buffer.from(source, 'base64').toString('utf-8');
+  return Buffer.from(source, "base64").toString("utf-8");
 }
 
 const originalNodeEnv = process.env.NODE_ENV;
-function stringifyFileScope({
-  packageName,
-  filePath
-}) {
+function stringifyFileScope({ packageName, filePath }) {
   return packageName ? `${filePath}$$$${packageName}` : filePath;
 }
 function parseFileScope(serialisedFileScope) {
-  const [filePath, packageName] = serialisedFileScope.split('$$$');
+  const [filePath, packageName] = serialisedFileScope.split("$$$");
   return {
     filePath,
-    packageName
+    packageName,
   };
 }
 async function processVanillaFile({
   source,
   filePath,
   outputCss = true,
-  identOption = process.env.NODE_ENV === 'production' ? 'short' : 'debug',
-  serializeVirtualCssPath
+  identOption = process.env.NODE_ENV === "production" ? "short" : "debug",
+  serializeVirtualCssPath,
 }) {
   const cssByFileScope = new Map();
   const localClassNames = new Set();
@@ -102,22 +113,26 @@ async function processVanillaFile({
       if (outputCss) {
         var _cssByFileScope$get;
         const serialisedFileScope = stringifyFileScope(fileScope);
-        const fileScopeCss = (_cssByFileScope$get = cssByFileScope.get(serialisedFileScope)) !== null && _cssByFileScope$get !== void 0 ? _cssByFileScope$get : [];
+        const fileScopeCss =
+          (_cssByFileScope$get = cssByFileScope.get(serialisedFileScope)) !==
+            null && _cssByFileScope$get !== void 0
+            ? _cssByFileScope$get
+            : [];
         fileScopeCss.push(css);
         cssByFileScope.set(serialisedFileScope, fileScopeCss);
       }
     },
-    registerClassName: className => {
+    registerClassName: (className) => {
       localClassNames.add(className);
     },
-    registerComposition: composedClassList => {
+    registerComposition: (composedClassList) => {
       composedClassLists.push(composedClassList);
     },
-    markCompositionUsed: identifier => {
+    markCompositionUsed: (identifier) => {
       usedCompositions.add(identifier);
     },
     onEndFileScope: () => {},
-    getIdentOption: () => identOption
+    getIdentOption: () => identOption,
   };
   const currentNodeEnv = process.env.NODE_ENV;
 
@@ -129,29 +144,36 @@ async function processVanillaFile({
     require('@vanilla-extract/css/adapter').setAdapter(__adapter__);
     ${source}
   `;
-  const evalResult = evalCode__default["default"](adapterBoundSource, filePath, {
-    console,
-    process,
-    __adapter__: cssAdapter
-  }, true);
+  const evalResult = evalCode__default["default"](
+    adapterBoundSource,
+    filePath,
+    {
+      console,
+      process,
+      __adapter__: cssAdapter,
+    },
+    true,
+  );
   process.env.NODE_ENV = currentNodeEnv;
   const cssImports = [];
   for (const [serialisedFileScope, fileScopeCss] of cssByFileScope) {
     const fileScope = parseFileScope(serialisedFileScope);
-    const css = transformCss.transformCss({
-      localClassNames: Array.from(localClassNames),
-      composedClassLists,
-      cssObjs: fileScopeCss
-    }).join('\n');
+    const css = transformCss
+      .transformCss({
+        localClassNames: Array.from(localClassNames),
+        composedClassLists,
+        cssObjs: fileScopeCss,
+      })
+      .join("\n");
     const fileName = `${fileScope.filePath}.vanilla.css`;
     let virtualCssFilePath;
     if (serializeVirtualCssPath) {
       const serializedResult = serializeVirtualCssPath({
         fileName,
         fileScope,
-        source: css
+        source: css,
       });
-      if (typeof serializedResult === 'string') {
+      if (typeof serializedResult === "string") {
         virtualCssFilePath = serializedResult;
       } else {
         virtualCssFilePath = await serializedResult;
@@ -165,78 +187,122 @@ async function processVanillaFile({
 
   // We run this code inside eval as jest seems to create a difrerent instance of the adapter file
   // for requires executed within the eval and all CSS can be lost.
-  evalCode__default["default"](`const { removeAdapter } = require('@vanilla-extract/css/adapter');
+  evalCode__default["default"](
+    `const { removeAdapter } = require('@vanilla-extract/css/adapter');
     // Backwards compat with older versions of @vanilla-extract/css
     if (removeAdapter) {
       removeAdapter();
     }
-  `, filePath, {
-    console,
-    process
-  }, true);
-  const unusedCompositions = composedClassLists.filter(({
-    identifier
-  }) => !usedCompositions.has(identifier)).map(({
-    identifier
-  }) => identifier);
-  const unusedCompositionRegex = unusedCompositions.length > 0 ? RegExp(`(${unusedCompositions.join('|')})\\s`, 'g') : null;
+  `,
+    filePath,
+    {
+      console,
+      process,
+    },
+    true,
+  );
+  const unusedCompositions = composedClassLists
+    .filter(({ identifier }) => !usedCompositions.has(identifier))
+    .map(({ identifier }) => identifier);
+  const unusedCompositionRegex =
+    unusedCompositions.length > 0
+      ? RegExp(`(${unusedCompositions.join("|")})\\s`, "g")
+      : null;
   return serializeVanillaModule(cssImports, evalResult, unusedCompositionRegex);
 }
-function stringifyExports(functionSerializationImports, value, unusedCompositionRegex, key, exportLookup, exportDependencyGraph) {
-  return javascriptStringify.stringify(value, (value, _indent, next) => {
-    const valueType = typeof value;
-    if (valueType === 'boolean' || valueType === 'number' || valueType === 'undefined' || value === null) {
-      return next(value);
-    }
-    if (Array.isArray(value) || isPlainObject__default["default"](value)) {
-      const reusedExport = exportLookup.get(value);
-      if (reusedExport && reusedExport !== key) {
-        exportDependencyGraph.addDependency(key, reusedExport);
-        return reusedExport;
+function stringifyExports(
+  functionSerializationImports,
+  value,
+  unusedCompositionRegex,
+  key,
+  exportLookup,
+  exportDependencyGraph,
+) {
+  return javascriptStringify.stringify(
+    value,
+    (value, _indent, next) => {
+      const valueType = typeof value;
+      if (
+        valueType === "boolean" ||
+        valueType === "number" ||
+        valueType === "undefined" ||
+        value === null
+      ) {
+        return next(value);
       }
-      return next(value);
-    }
-    if (Symbol.toStringTag in Object(value)) {
-      const {
-        [Symbol.toStringTag]: _tag,
-        ...valueWithoutTag
-      } = value;
-      return next(valueWithoutTag);
-    }
-    if (valueType === 'string') {
-      return next(unusedCompositionRegex ? value.replace(unusedCompositionRegex, '') : value);
-    }
-    if (valueType === 'function' && (value.__function_serializer__ || value.__recipe__)) {
-      const {
-        importPath,
-        importName,
-        args
-      } = value.__function_serializer__ || value.__recipe__;
-      if (typeof importPath !== 'string' || typeof importName !== 'string' || !Array.isArray(args)) {
-        throw new Error('Invalid function serialization params');
+      if (Array.isArray(value) || isPlainObject__default["default"](value)) {
+        const reusedExport = exportLookup.get(value);
+        if (reusedExport && reusedExport !== key) {
+          exportDependencyGraph.addDependency(key, reusedExport);
+          return reusedExport;
+        }
+        return next(value);
       }
-      try {
-        const hashedImportName = `_${hash(`${importName}${importPath}`).slice(0, 5)}`;
-        functionSerializationImports.add(`import { ${importName} as ${hashedImportName} } from '${importPath}';`);
-        return `${hashedImportName}(${args.map(arg => stringifyExports(functionSerializationImports, arg, unusedCompositionRegex, key, exportLookup, exportDependencyGraph)).join(',')})`;
-      } catch (err) {
-        console.error(err);
-        throw new Error('Invalid function serialization params');
+      if (Symbol.toStringTag in Object(value)) {
+        const { [Symbol.toStringTag]: _tag, ...valueWithoutTag } = value;
+        return next(valueWithoutTag);
       }
-    }
-    throw new Error(outdent__default["default"]`
+      if (valueType === "string") {
+        return next(
+          unusedCompositionRegex
+            ? value.replace(unusedCompositionRegex, "")
+            : value,
+        );
+      }
+      if (
+        valueType === "function" &&
+        (value.__function_serializer__ || value.__recipe__)
+      ) {
+        const { importPath, importName, args } =
+          value.__function_serializer__ || value.__recipe__;
+        if (
+          typeof importPath !== "string" ||
+          typeof importName !== "string" ||
+          !Array.isArray(args)
+        ) {
+          throw new Error("Invalid function serialization params");
+        }
+        try {
+          const hashedImportName = `_${hash(`${importName}${importPath}`).slice(
+            0,
+            5,
+          )}`;
+          functionSerializationImports.add(
+            `import { ${importName} as ${hashedImportName} } from '${importPath}';`,
+          );
+          return `${hashedImportName}(${args
+            .map((arg) =>
+              stringifyExports(
+                functionSerializationImports,
+                arg,
+                unusedCompositionRegex,
+                key,
+                exportLookup,
+                exportDependencyGraph,
+              ),
+            )
+            .join(",")})`;
+        } catch (err) {
+          console.error(err);
+          throw new Error("Invalid function serialization params");
+        }
+      }
+      throw new Error(outdent__default["default"]`
         Invalid exports.
 
         You can only export plain objects, arrays, strings, numbers and null/undefined.
       `);
-  }, 0, {
-    references: true,
-    // Allow circular references
-    maxDepth: Infinity,
-    maxValues: Infinity
-  });
+    },
+    0,
+    {
+      references: true,
+      // Allow circular references
+      maxDepth: Infinity,
+      maxValues: Infinity,
+    },
+  );
 }
-const defaultExportName = '__default__';
+const defaultExportName = "__default__";
 class DependencyGraph {
   constructor() {
     this.graph = new Map();
@@ -260,7 +326,11 @@ class DependencyGraph {
   dependsOn(key, dependency) {
     const dependencies = this.graph.get(key);
     if (dependencies) {
-      if (dependencies !== null && dependencies !== void 0 && dependencies.has(dependency)) {
+      if (
+        dependencies !== null &&
+        dependencies !== void 0 &&
+        dependencies.has(dependency)
+      ) {
         return true;
       }
       for (const [dep] of dependencies.entries()) {
@@ -274,52 +344,74 @@ class DependencyGraph {
 }
 function serializeVanillaModule(cssImports, exports, unusedCompositionRegex) {
   const functionSerializationImports = new Set();
-  const exportLookup = new Map(Object.entries(exports).map(([key, value]) => [value, key === 'default' ? defaultExportName : key]));
+  const exportLookup = new Map(
+    Object.entries(exports).map(([key, value]) => [
+      value,
+      key === "default" ? defaultExportName : key,
+    ]),
+  );
   const exportDependencyGraph = new DependencyGraph();
   const moduleExports = Object.entries(exports).map(([key, value]) => {
-    const serializedExport = stringifyExports(functionSerializationImports, value, unusedCompositionRegex, key === 'default' ? defaultExportName : key, exportLookup, exportDependencyGraph);
-    if (key === 'default') {
-      return [defaultExportName, [`var ${defaultExportName} = ${serializedExport};`, `export default ${defaultExportName};`].join('\n')];
+    const serializedExport = stringifyExports(
+      functionSerializationImports,
+      value,
+      unusedCompositionRegex,
+      key === "default" ? defaultExportName : key,
+      exportLookup,
+      exportDependencyGraph,
+    );
+    if (key === "default") {
+      return [
+        defaultExportName,
+        [
+          `var ${defaultExportName} = ${serializedExport};`,
+          `export default ${defaultExportName};`,
+        ].join("\n"),
+      ];
     }
     return [key, `export var ${key} = ${serializedExport};`];
   });
-  const sortedModuleExports = moduleExports.sort(([key1], [key2]) => {
-    if (exportDependencyGraph.dependsOn(key1, key2)) {
-      return 1;
-    }
-    if (exportDependencyGraph.dependsOn(key2, key1)) {
-      return -1;
-    }
-    return 0;
-  }).map(([, s]) => s);
-  const outputCode = [...cssImports, ...functionSerializationImports, ...sortedModuleExports];
-  return outputCode.join('\n');
+  const sortedModuleExports = moduleExports
+    .sort(([key1], [key2]) => {
+      if (exportDependencyGraph.dependsOn(key1, key2)) {
+        return 1;
+      }
+      if (exportDependencyGraph.dependsOn(key2, key1)) {
+        return -1;
+      }
+      return 0;
+    })
+    .map(([, s]) => s);
+  const outputCode = [
+    ...cssImports,
+    ...functionSerializationImports,
+    ...sortedModuleExports,
+  ];
+  return outputCode.join("\n");
 }
 
 async function getSourceFromVirtualCssFile(id) {
   const match = id.match(/^(?<fileName>.*)\?source=(?<source>.*)$/);
   if (!match || !match.groups) {
-    throw new Error('No source in vanilla CSS file');
+    throw new Error("No source in vanilla CSS file");
   }
   const source = await deserializeCss(match.groups.source);
   return {
     fileName: match.groups.fileName,
-    source
+    source,
   };
 }
 
 function getClosestPackageInfo(directory) {
-  const packageJsonPath = findUp__default["default"].sync('package.json', {
-    cwd: directory
+  const packageJsonPath = findUp__default["default"].sync("package.json", {
+    cwd: directory,
   });
   if (packageJsonPath) {
-    const {
-      name
-    } = require(packageJsonPath);
+    const { name } = require(packageJsonPath);
     return {
       name,
       path: packageJsonPath,
-      dirname: path__default["default"].dirname(packageJsonPath)
+      dirname: path__default["default"].dirname(packageJsonPath),
     };
   }
 }
@@ -332,10 +424,14 @@ function getPackageInfo(cwd) {
   }
   let packageInfo = getClosestPackageInfo(resolvedCwd);
   while (packageInfo && !packageInfo.name) {
-    packageInfo = getClosestPackageInfo(path__default["default"].resolve(packageInfo.dirname, '..'));
+    packageInfo = getClosestPackageInfo(
+      path__default["default"].resolve(packageInfo.dirname, ".."),
+    );
   }
   if (!packageInfo || !packageInfo.name) {
-    throw new Error(`Couldn't find parent package.json with a name field from '${resolvedCwd}'`);
+    throw new Error(
+      `Couldn't find parent package.json with a name field from '${resolvedCwd}'`,
+    );
   }
   packageInfoCache.set(resolvedCwd, packageInfo);
   return packageInfo;
@@ -351,23 +447,29 @@ function addFileScope({
   filePath,
   rootPath,
   packageName,
-  globalAdapterIdentifier
+  globalAdapterIdentifier,
 }) {
   // Encode windows file paths as posix
-  const normalizedPath = path.posix.join(...path.relative(rootPath, filePath).split(path.sep));
-  if (source.indexOf('@vanilla-extract/css/fileScope') > -1) {
-    return source.replace(/setFileScope\(((\n|.)*?)\)/, `setFileScope("${normalizedPath}", "${packageName}")`);
+  const normalizedPath = path.posix.join(
+    ...path.relative(rootPath, filePath).split(path.sep),
+  );
+  if (source.indexOf("@vanilla-extract/css/fileScope") > -1) {
+    return source.replace(
+      /setFileScope\(((\n|.)*?)\)/,
+      `setFileScope("${normalizedPath}", "${packageName}")`,
+    );
   }
-  const {
-    hasESM,
-    isMixed
-  } = mlly.detectSyntax(source);
+  const { hasESM, isMixed } = mlly.detectSyntax(source);
   if (hasESM && !isMixed) {
-    const setAdapterSnippet = globalAdapterIdentifier ? `
+    const setAdapterSnippet = globalAdapterIdentifier
+      ? `
         import * as __vanilla_css_adapter__ from "@vanilla-extract/css/adapter";
         __vanilla_css_adapter__.setAdapter(${globalAdapterIdentifier});
-      ` : '';
-    const removeAdapterSnippet = setAdapterSnippet ? '__vanilla_css_adapter__.removeAdapter();' : '';
+      `
+      : "";
+    const removeAdapterSnippet = setAdapterSnippet
+      ? "__vanilla_css_adapter__.removeAdapter();"
+      : "";
     return `
       ${setAdapterSnippet}
       import { setFileScope, endFileScope } from "@vanilla-extract/css/fileScope";
@@ -377,11 +479,15 @@ function addFileScope({
       ${removeAdapterSnippet}
     `;
   }
-  const setAdapterSnippet = globalAdapterIdentifier ? `
+  const setAdapterSnippet = globalAdapterIdentifier
+    ? `
       const __vanilla_css_adapter__ = require("@vanilla-extract/css/adapter");
       __vanilla_css_adapter__.setAdapter(${globalAdapterIdentifier});
-    ` : '';
-  const removeAdapterSnippet = setAdapterSnippet ? '__vanilla_css_adapter__.removeAdapter();' : '';
+    `
+    : "";
+  const removeAdapterSnippet = setAdapterSnippet
+    ? "__vanilla_css_adapter__.removeAdapter();"
+    : "";
   return `
     ${setAdapterSnippet}
     const __vanilla_filescope__ = require("@vanilla-extract/css/fileScope");
@@ -397,19 +503,22 @@ const transformSync = ({
   filePath,
   rootPath,
   packageName,
-  identOption
+  identOption,
 }) => {
   let code = source;
-  if (identOption === 'debug') {
+  if (identOption === "debug") {
     const result = babel__namespace.transformSync(source, {
       filename: filePath,
       cwd: rootPath,
-      plugins: [vanillaBabelPlugin__default["default"], typescriptSyntax__default["default"]],
+      plugins: [
+        vanillaBabelPlugin__default["default"],
+        typescriptSyntax__default["default"],
+      ],
       configFile: false,
-      babelrc: false
+      babelrc: false,
     });
     if (!result || result.code == null) {
-      throw new Error('Error adding debug IDs');
+      throw new Error("Error adding debug IDs");
     }
     code = result.code;
   }
@@ -417,7 +526,7 @@ const transformSync = ({
     source: code,
     filePath,
     rootPath,
-    packageName
+    packageName,
   });
 };
 const transform = async ({
@@ -426,19 +535,22 @@ const transform = async ({
   rootPath,
   packageName,
   identOption,
-  globalAdapterIdentifier
+  globalAdapterIdentifier,
 }) => {
   let code = source;
-  if (identOption === 'debug') {
+  if (identOption === "debug") {
     const result = await babel__namespace.transformAsync(source, {
       filename: filePath,
       cwd: rootPath,
-      plugins: [vanillaBabelPlugin__default["default"], typescriptSyntax__default["default"]],
+      plugins: [
+        vanillaBabelPlugin__default["default"],
+        typescriptSyntax__default["default"],
+      ],
       configFile: false,
-      babelrc: false
+      babelrc: false,
     });
     if (!result || result.code == null) {
-      throw new Error('Error adding debug IDs');
+      throw new Error("Error adding debug IDs");
     }
     code = result.code;
   }
@@ -447,69 +559,99 @@ const transform = async ({
     filePath,
     rootPath,
     packageName,
-    globalAdapterIdentifier
+    globalAdapterIdentifier,
   });
 };
 
-const vanillaExtractTransformPlugin = ({
-  identOption
-}) => ({
-  name: 'vanilla-extract-filescope',
+const vanillaExtractTransformPlugin = ({ identOption }) => ({
+  name: "vanilla-extract-filescope",
   setup(build) {
     const packageInfo = getPackageInfo(build.initialOptions.absWorkingDir);
-    build.onLoad({
-      filter: cssFileFilter
-    }, async ({
-      path: path$1
-    }) => {
-      const originalSource = await fs.promises.readFile(path$1, 'utf-8');
-      const source = await transform({
-        source: originalSource,
-        filePath: path$1,
-        rootPath: build.initialOptions.absWorkingDir,
-        packageName: packageInfo.name,
-        identOption: identOption !== null && identOption !== void 0 ? identOption : build.initialOptions.minify ? 'short' : 'debug'
-      });
-      return {
-        contents: source,
-        loader: path$1.match(/\.(ts|tsx)$/i) ? 'ts' : undefined,
-        resolveDir: path.dirname(path$1)
-      };
-    });
-  }
+    build.onLoad(
+      {
+        filter: cssFileFilter,
+      },
+      async ({ path: path$1 }) => {
+        const originalSource = await fs.promises.readFile(path$1, "utf-8");
+        const source = await transform({
+          source: originalSource,
+          filePath: path$1,
+          rootPath: build.initialOptions.absWorkingDir,
+          packageName: packageInfo.name,
+          identOption:
+            identOption !== null && identOption !== void 0
+              ? identOption
+              : build.initialOptions.minify
+              ? "short"
+              : "debug",
+        });
+        return {
+          contents: source,
+          loader: path$1.match(/\.(ts|tsx)$/i) ? "ts" : undefined,
+          resolveDir: path.dirname(path$1),
+        };
+      },
+    );
+  },
 });
 async function compile({
   filePath,
   identOption,
   cwd = process.cwd(),
-  esbuildOptions
+  esbuildOptions,
 }) {
   var _esbuildOptions$exter, _esbuildOptions$plugi;
   const result = await esbuild.build({
     entryPoints: [filePath],
     metafile: true,
     bundle: true,
-    external: ['@vanilla-extract', ...((_esbuildOptions$exter = esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.external) !== null && _esbuildOptions$exter !== void 0 ? _esbuildOptions$exter : [])],
-    platform: 'node',
+    external: [
+      "@vanilla-extract",
+      ...((_esbuildOptions$exter =
+        esbuildOptions === null || esbuildOptions === void 0
+          ? void 0
+          : esbuildOptions.external) !== null &&
+      _esbuildOptions$exter !== void 0
+        ? _esbuildOptions$exter
+        : []),
+    ],
+    platform: "node",
     write: false,
-    plugins: [vanillaExtractTransformPlugin({
-      identOption
-    }), ...((_esbuildOptions$plugi = esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.plugins) !== null && _esbuildOptions$plugi !== void 0 ? _esbuildOptions$plugi : [])],
+    plugins: [
+      vanillaExtractTransformPlugin({
+        identOption,
+      }),
+      ...((_esbuildOptions$plugi =
+        esbuildOptions === null || esbuildOptions === void 0
+          ? void 0
+          : esbuildOptions.plugins) !== null && _esbuildOptions$plugi !== void 0
+        ? _esbuildOptions$plugi
+        : []),
+    ],
     absWorkingDir: cwd,
-    loader: esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.loader,
-    define: esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.define,
-    tsconfig: esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.tsconfig
+    loader:
+      esbuildOptions === null || esbuildOptions === void 0
+        ? void 0
+        : esbuildOptions.loader,
+    define:
+      esbuildOptions === null || esbuildOptions === void 0
+        ? void 0
+        : esbuildOptions.define,
+    tsconfig:
+      esbuildOptions === null || esbuildOptions === void 0
+        ? void 0
+        : esbuildOptions.tsconfig,
   });
-  const {
-    outputFiles,
-    metafile
-  } = result;
+  const { outputFiles, metafile } = result;
   if (!outputFiles || outputFiles.length !== 1) {
-    throw new Error('Invalid child compilation');
+    throw new Error("Invalid child compilation");
   }
   return {
     source: outputFiles[0].text,
-    watchFiles: Object.keys((metafile === null || metafile === void 0 ? void 0 : metafile.inputs) || {}).map(filePath => path.join(cwd, filePath))
+    watchFiles: Object.keys(
+      (metafile === null || metafile === void 0 ? void 0 : metafile.inputs) ||
+        {},
+    ).map((filePath) => path.join(cwd, filePath)),
   };
 }
 
@@ -543,7 +685,7 @@ async function processQueue() {
   await fn();
 }
 
-const globalAdapterIdentifier = '__vanilla_globalCssAdapter__';
+const globalAdapterIdentifier = "__vanilla_globalCssAdapter__";
 const scanModule = (entryModule, root) => {
   const queue = [entryModule];
   const cssDeps = new Set();
@@ -563,72 +705,77 @@ const scanModule = (entryModule, root) => {
   const [head, ...tail] = cssDeps;
   return {
     cssDeps: [...tail, head],
-    watchFiles
+    watchFiles,
   };
 };
 
 // We lazily load this utility from Vite
 let normalizeModuleId;
-const createViteServer = async ({
-  root,
-  identifiers,
-  vitePlugins = []
-}) => {
+const createViteServer = async ({ root, identifiers, vitePlugins = [] }) => {
   const pkg = getPackageInfo(root);
-  const vite = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('vite')); });
+  const vite = await Promise.resolve().then(function () {
+    return /*#__PURE__*/ _interopNamespace(require("vite"));
+  });
   normalizeModuleId = vite.normalizePath;
   const server = await vite.createServer({
+    configFile: false,
     root,
     server: {
-      hmr: false
+      hmr: false,
     },
-    logLevel: 'silent',
+    logLevel: "silent",
     optimizeDeps: {
-      disabled: true
+      disabled: true,
     },
     ssr: {
-      noExternal: true
+      noExternal: true,
     },
-    plugins: [{
-      name: 'vanilla-extract-externalize',
-      enforce: 'pre',
-      async resolveId(source, importer) {
-        if (source.startsWith('@vanilla-extract/')) {
-          const result = await this.resolve(source, importer, {
-            skipSelf: true
-          });
-          return result ? {
-            ...result,
-            external: true
-          } : null;
-        }
-      }
-    }, {
-      name: 'vanilla-extract-transform',
-      async transform(code, id) {
-        if (cssFileFilter.test(id)) {
-          const filescopedCode = await transform({
-            source: code,
-            rootPath: root,
-            filePath: id,
-            packageName: pkg.name,
-            identOption: identifiers,
-            globalAdapterIdentifier
-          });
-          return filescopedCode;
-        }
-      }
-    }, ...vitePlugins]
+    plugins: [
+      {
+        name: "vanilla-extract-externalize",
+        enforce: "pre",
+        async resolveId(source, importer) {
+          if (source.startsWith("@vanilla-extract/")) {
+            const result = await this.resolve(source, importer, {
+              skipSelf: true,
+            });
+            return result
+              ? {
+                  ...result,
+                  external: true,
+                }
+              : null;
+          }
+        },
+      },
+      {
+        name: "vanilla-extract-transform",
+        async transform(code, id) {
+          if (cssFileFilter.test(id)) {
+            const filescopedCode = await transform({
+              source: code,
+              rootPath: root,
+              filePath: id,
+              packageName: pkg.name,
+              identOption: identifiers,
+              globalAdapterIdentifier,
+            });
+            return filescopedCode;
+          }
+        },
+      },
+      ...vitePlugins,
+    ],
   });
 
   // this is need to initialize the plugins
   await server.pluginContainer.buildStart({});
-  const {
-    ViteNodeRunner
-  } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('vite-node/client')); });
-  const {
-    ViteNodeServer
-  } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('vite-node/server')); });
+  const { ViteNodeRunner } = await Promise.resolve().then(function () {
+    return /*#__PURE__*/ _interopNamespace(require("vite-node/client"));
+  });
+  const { ViteNodeServer } = await Promise.resolve().then(function () {
+    return /*#__PURE__*/ _interopNamespace(require("vite-node/server"));
+  });
   const node = new ViteNodeServer(server);
   const runner = new ViteNodeRunner({
     root,
@@ -638,36 +785,33 @@ const createViteServer = async ({
     },
     resolveId(id, importer) {
       return node.resolveId(id, importer);
-    }
+    },
   });
-  server.watcher.on('change', filePath => {
+  server.watcher.on("change", (filePath) => {
     runner.moduleCache.invalidateDepTree([filePath]);
   });
   return {
     server,
-    runner
+    runner,
   };
 };
 const createCompiler = ({
   root,
-  identifiers = 'debug',
-  cssImportSpecifier = filePath => filePath + '.vanilla.css',
-  vitePlugins
+  identifiers = "debug",
+  cssImportSpecifier = (filePath) => filePath + ".vanilla.css",
+  vitePlugins,
 }) => {
   let originalPrepareContext;
   const vitePromise = createViteServer({
     root,
     identifiers,
-    vitePlugins
-  }).then(({
-    server,
-    runner
-  }) => {
+    vitePlugins,
+  }).then(({ server, runner }) => {
     // Store the original method so we can monkey patch it on demand
     originalPrepareContext = runner.prepareContext;
     return {
       server,
-      runner
+      runner,
     };
   });
   const cssCache = new Map();
@@ -676,20 +820,30 @@ const createCompiler = ({
   return {
     async processVanillaFile(filePath, options = {}) {
       var _options$outputCss;
-      const {
-        server,
-        runner
-      } = await vitePromise;
-      filePath = path.isAbsolute(filePath) ? filePath : path.join(root, filePath);
-      const outputCss = (_options$outputCss = options.outputCss) !== null && _options$outputCss !== void 0 ? _options$outputCss : true;
+      const { server, runner } = await vitePromise;
+      filePath = path.isAbsolute(filePath)
+        ? filePath
+        : path.join(root, filePath);
+      const outputCss =
+        (_options$outputCss = options.outputCss) !== null &&
+        _options$outputCss !== void 0
+          ? _options$outputCss
+          : true;
       const cacheKey = Object.entries({
         filePath,
-        outputCss
-      }).map(entry => entry.join('=')).join('|');
+        outputCss,
+      })
+        .map((entry) => entry.join("="))
+        .join("|");
       const cachedFile = processVanillaFileCache.get(cacheKey);
       if (cachedFile) {
         const moduleNode = server.moduleGraph.getModuleById(filePath);
-        if (cachedFile.lastInvalidationTimestamp === (moduleNode === null || moduleNode === void 0 ? void 0 : moduleNode.lastInvalidationTimestamp)) {
+        if (
+          cachedFile.lastInvalidationTimestamp ===
+          (moduleNode === null || moduleNode === void 0
+            ? void 0
+            : moduleNode.lastInvalidationTimestamp)
+        ) {
           return cachedFile.result;
         }
       }
@@ -698,41 +852,51 @@ const createCompiler = ({
       const composedClassLists = [];
       const cssAdapter = {
         getIdentOption: () => identifiers,
-        onBeginFileScope: fileScope => {
+        onBeginFileScope: (fileScope) => {
           // Before evaluating a file, reset the cache for it
           const moduleId = normalizeModuleId(fileScope.filePath);
           cssByModuleId.set(moduleId, []);
           classRegistrationsByModuleId.set(moduleId, {
             localClassNames: new Set(),
-            composedClassLists: []
+            composedClassLists: [],
           });
         },
-        onEndFileScope: ({
-          filePath
-        }) => {
+        onEndFileScope: ({ filePath }) => {
           var _cssByModuleId$get;
           // For backwards compatibility, ensure the cache is populated even if
           // a file didn't contain any CSS. This is to ensure that the only
           // error messages shown in older versions are the ones below.
           const moduleId = normalizeModuleId(filePath);
-          const cssObjs = (_cssByModuleId$get = cssByModuleId.get(moduleId)) !== null && _cssByModuleId$get !== void 0 ? _cssByModuleId$get : [];
+          const cssObjs =
+            (_cssByModuleId$get = cssByModuleId.get(moduleId)) !== null &&
+            _cssByModuleId$get !== void 0
+              ? _cssByModuleId$get
+              : [];
           cssByModuleId.set(moduleId, cssObjs);
         },
         registerClassName: (className, fileScope) => {
           if (!fileScope) {
-            throw new Error('Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.');
+            throw new Error(
+              "Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.",
+            );
           }
           localClassNames.add(className);
           const moduleId = normalizeModuleId(fileScope.filePath);
-          classRegistrationsByModuleId.get(moduleId).localClassNames.add(className);
+          classRegistrationsByModuleId
+            .get(moduleId)
+            .localClassNames.add(className);
         },
         registerComposition: (composedClassList, fileScope) => {
           if (!fileScope) {
-            throw new Error('Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.');
+            throw new Error(
+              "Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.",
+            );
           }
           composedClassLists.push(composedClassList);
           const moduleId = normalizeModuleId(fileScope.filePath);
-          classRegistrationsByModuleId.get(moduleId).composedClassLists.push(composedClassList);
+          classRegistrationsByModuleId
+            .get(moduleId)
+            .composedClassLists.push(composedClassList);
         },
         markCompositionUsed: () => {
           // This compiler currently retains all composition classes
@@ -740,86 +904,102 @@ const createCompiler = ({
         appendCss: (css, fileScope) => {
           var _cssByModuleId$get2;
           const moduleId = normalizeModuleId(fileScope.filePath);
-          const cssObjs = (_cssByModuleId$get2 = cssByModuleId.get(moduleId)) !== null && _cssByModuleId$get2 !== void 0 ? _cssByModuleId$get2 : [];
+          const cssObjs =
+            (_cssByModuleId$get2 = cssByModuleId.get(moduleId)) !== null &&
+            _cssByModuleId$get2 !== void 0
+              ? _cssByModuleId$get2
+              : [];
           cssObjs.push(css);
           cssByModuleId.set(moduleId, cssObjs);
-        }
+        },
       };
-      const {
-        fileExports,
-        cssImports,
-        watchFiles,
-        lastInvalidationTimestamp
-      } = await lock(async () => {
-        // Monkey patch the prepareContext method to inject the adapter
-        runner.prepareContext = function (...args) {
-          return {
-            ...originalPrepareContext.apply(this, args),
-            [globalAdapterIdentifier]: cssAdapter
+      const { fileExports, cssImports, watchFiles, lastInvalidationTimestamp } =
+        await lock(async () => {
+          // Monkey patch the prepareContext method to inject the adapter
+          runner.prepareContext = function (...args) {
+            return {
+              ...originalPrepareContext.apply(this, args),
+              [globalAdapterIdentifier]: cssAdapter,
+            };
           };
-        };
-        const fileExports = await runner.executeFile(filePath);
-        const moduleId = normalizeModuleId(filePath);
-        const moduleNode = server.moduleGraph.getModuleById(moduleId);
-        if (!moduleNode) {
-          throw new Error(`Can't find ModuleNode for ${filePath}`);
-        }
-        const cssImports = [];
-        const {
-          cssDeps,
-          watchFiles
-        } = scanModule(moduleNode, root);
-        for (const cssDep of cssDeps) {
-          const cssDepModuleId = normalizeModuleId(cssDep);
-          const cssObjs = cssByModuleId.get(cssDepModuleId);
-          const cachedCss = cssCache.get(cssDepModuleId);
-          const cachedClassRegistrations = classRegistrationsByModuleId.get(cssDepModuleId);
-          if (!cssObjs && !cachedCss && !cachedClassRegistrations) {
-            continue;
-          }
-          if (cssObjs) {
-            const css = transformCss.transformCss({
-              localClassNames: Array.from(localClassNames),
-              composedClassLists,
-              cssObjs
-            }).join('\n');
-            cssCache.set(cssDepModuleId, {
-              css
-            });
-          } else if (cachedClassRegistrations) {
-            cachedClassRegistrations.localClassNames.forEach(localClassName => {
-              localClassNames.add(localClassName);
-            });
-            composedClassLists.push(...cachedClassRegistrations.composedClassLists);
+          const fileExports = await runner.executeFile(filePath);
+          const moduleId = normalizeModuleId(filePath);
+          const moduleNode = server.moduleGraph.getModuleById(moduleId);
+          if (!moduleNode) {
+            throw new Error(`Can't find ModuleNode for ${filePath}`);
           }
-          if (cssObjs || cachedCss !== null && cachedCss !== void 0 && cachedCss.css) {
-            cssImports.push(`import '${cssImportSpecifier(cssDepModuleId)}';`);
+          const cssImports = [];
+          const { cssDeps, watchFiles } = scanModule(moduleNode, root);
+          for (const cssDep of cssDeps) {
+            const cssDepModuleId = normalizeModuleId(cssDep);
+            const cssObjs = cssByModuleId.get(cssDepModuleId);
+            const cachedCss = cssCache.get(cssDepModuleId);
+            const cachedClassRegistrations =
+              classRegistrationsByModuleId.get(cssDepModuleId);
+            if (!cssObjs && !cachedCss && !cachedClassRegistrations) {
+              continue;
+            }
+            if (cssObjs) {
+              const css = transformCss
+                .transformCss({
+                  localClassNames: Array.from(localClassNames),
+                  composedClassLists,
+                  cssObjs,
+                })
+                .join("\n");
+              cssCache.set(cssDepModuleId, {
+                css,
+              });
+            } else if (cachedClassRegistrations) {
+              cachedClassRegistrations.localClassNames.forEach(
+                (localClassName) => {
+                  localClassNames.add(localClassName);
+                },
+              );
+              composedClassLists.push(
+                ...cachedClassRegistrations.composedClassLists,
+              );
+            }
+            if (
+              cssObjs ||
+              (cachedCss !== null && cachedCss !== void 0 && cachedCss.css)
+            ) {
+              cssImports.push(
+                `import '${cssImportSpecifier(cssDepModuleId)}';`,
+              );
+            }
           }
-        }
-        return {
-          fileExports,
-          cssImports: outputCss ? cssImports : [],
-          watchFiles,
-          lastInvalidationTimestamp: moduleNode.lastInvalidationTimestamp
-        };
-      });
+          return {
+            fileExports,
+            cssImports: outputCss ? cssImports : [],
+            watchFiles,
+            lastInvalidationTimestamp: moduleNode.lastInvalidationTimestamp,
+          };
+        });
       const result = {
-        source: serializeVanillaModule(cssImports, fileExports, null // This compiler currently retains all composition classes
+        source: serializeVanillaModule(
+          cssImports,
+          fileExports,
+          null, // This compiler currently retains all composition classes
         ),
 
-        watchFiles
+        watchFiles,
       };
       processVanillaFileCache.set(cacheKey, {
         lastInvalidationTimestamp,
-        result
+        result,
       });
       return result;
     },
     getCssForFile(filePath) {
       if (!normalizeModuleId) {
-        throw new Error(`Compiler is still loading. No CSS for file: ${filePath}`);
+        throw new Error(
+          `Compiler is still loading. No CSS for file: ${filePath}`,
+        );
       }
-      filePath = path.isAbsolute(filePath) ? filePath : path.join(root, filePath);
+      filePath = path.isAbsolute(filePath)
+        ? filePath
+        : path.join(root, filePath);
       const rootRelativePath = path.relative(root, filePath);
       const moduleId = normalizeModuleId(rootRelativePath);
       const result = cssCache.get(moduleId);
@@ -829,15 +1009,13 @@ const createCompiler = ({
       return {
         css: result.css,
         filePath: rootRelativePath,
-        resolveDir: root
+        resolveDir: root,
       };
     },
     async close() {
-      const {
-        server
-      } = await vitePromise;
+      const { server } = await vitePromise;
       await server.close();
-    }
+    },
   };
 };
 
diff --git a/dist/vanilla-extract-integration.cjs.prod.js b/dist/vanilla-extract-integration.cjs.prod.js
index a3a77fb1b8fb64d0a32986f5a5da15fcc632c67f..2b968df283e68ce92196802894ae2bed6d9595c4 100644
--- a/dist/vanilla-extract-integration.cjs.prod.js
+++ b/dist/vanilla-extract-integration.cjs.prod.js
@@ -1,37 +1,47 @@
-'use strict';
+"use strict";
 
-Object.defineProperty(exports, '__esModule', { value: true });
+Object.defineProperty(exports, "__esModule", { value: true });
 
-var transformCss = require('@vanilla-extract/css/transformCss');
-var evalCode = require('eval');
-var javascriptStringify = require('javascript-stringify');
-var isPlainObject = require('lodash/isPlainObject');
-var outdent = require('outdent');
-var crypto = require('crypto');
-var zlib = require('zlib');
-var util = require('util');
-var path = require('path');
-var findUp = require('find-up');
-var fs = require('fs');
-var esbuild = require('esbuild');
-var babel = require('@babel/core');
-var vanillaBabelPlugin = require('@vanilla-extract/babel-plugin-debug-ids');
-var typescriptSyntax = require('@babel/plugin-syntax-typescript');
-var mlly = require('mlly');
+var transformCss = require("@vanilla-extract/css/transformCss");
+var evalCode = require("eval");
+var javascriptStringify = require("javascript-stringify");
+var isPlainObject = require("lodash/isPlainObject");
+var outdent = require("outdent");
+var crypto = require("crypto");
+var zlib = require("zlib");
+var util = require("util");
+var path = require("path");
+var findUp = require("find-up");
+var fs = require("fs");
+var esbuild = require("esbuild");
+var babel = require("@babel/core");
+var vanillaBabelPlugin = require("@vanilla-extract/babel-plugin-debug-ids");
+var typescriptSyntax = require("@babel/plugin-syntax-typescript");
+var mlly = require("mlly");
 
-function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }
+function _interopDefault(e) {
+  return e && e.__esModule ? e : { default: e };
+}
 
 function _interopNamespace(e) {
   if (e && e.__esModule) return e;
   var n = Object.create(null);
   if (e) {
     Object.keys(e).forEach(function (k) {
-      if (k !== 'default') {
+      if (k !== "default") {
         var d = Object.getOwnPropertyDescriptor(e, k);
-        Object.defineProperty(n, k, d.get ? d : {
-          enumerable: true,
-          get: function () { return e[k]; }
-        });
+        Object.defineProperty(
+          n,
+          k,
+          d.get
+            ? d
+            : {
+                enumerable: true,
+                get: function () {
+                  return e[k];
+                },
+              },
+        );
       }
     });
   }
@@ -39,59 +49,60 @@ function _interopNamespace(e) {
   return Object.freeze(n);
 }
 
-var evalCode__default = /*#__PURE__*/_interopDefault(evalCode);
-var isPlainObject__default = /*#__PURE__*/_interopDefault(isPlainObject);
-var outdent__default = /*#__PURE__*/_interopDefault(outdent);
-var crypto__default = /*#__PURE__*/_interopDefault(crypto);
-var path__default = /*#__PURE__*/_interopDefault(path);
-var findUp__default = /*#__PURE__*/_interopDefault(findUp);
-var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
-var vanillaBabelPlugin__default = /*#__PURE__*/_interopDefault(vanillaBabelPlugin);
-var typescriptSyntax__default = /*#__PURE__*/_interopDefault(typescriptSyntax);
+var evalCode__default = /*#__PURE__*/ _interopDefault(evalCode);
+var isPlainObject__default = /*#__PURE__*/ _interopDefault(isPlainObject);
+var outdent__default = /*#__PURE__*/ _interopDefault(outdent);
+var crypto__default = /*#__PURE__*/ _interopDefault(crypto);
+var path__default = /*#__PURE__*/ _interopDefault(path);
+var findUp__default = /*#__PURE__*/ _interopDefault(findUp);
+var babel__namespace = /*#__PURE__*/ _interopNamespace(babel);
+var vanillaBabelPlugin__default =
+  /*#__PURE__*/ _interopDefault(vanillaBabelPlugin);
+var typescriptSyntax__default = /*#__PURE__*/ _interopDefault(typescriptSyntax);
 
-const hash = value => crypto__default["default"].createHash('md5').update(value).digest('hex');
+const hash = (value) =>
+  crypto__default["default"].createHash("md5").update(value).digest("hex");
 
 const zip = util.promisify(zlib.gzip);
 const unzip = util.promisify(zlib.gunzip);
 
 // The byte threshold for applying compression, below which compressing would out-weigh its value.
 const compressionThreshold = 1000;
-const compressionFlag = '#';
+const compressionFlag = "#";
 async function serializeCss(source) {
   if (source.length > compressionThreshold) {
     const compressedSource = await zip(source);
-    return compressionFlag + compressedSource.toString('base64');
+    return compressionFlag + compressedSource.toString("base64");
   }
-  return Buffer.from(source, 'utf-8').toString('base64');
+  return Buffer.from(source, "utf-8").toString("base64");
 }
 async function deserializeCss(source) {
   if (source.indexOf(compressionFlag) > -1) {
-    const decompressedSource = await unzip(Buffer.from(source.replace(compressionFlag, ''), 'base64'));
-    return decompressedSource.toString('utf-8');
+    const decompressedSource = await unzip(
+      Buffer.from(source.replace(compressionFlag, ""), "base64"),
+    );
+    return decompressedSource.toString("utf-8");
   }
-  return Buffer.from(source, 'base64').toString('utf-8');
+  return Buffer.from(source, "base64").toString("utf-8");
 }
 
-const originalNodeEnv =         "production";
-function stringifyFileScope({
-  packageName,
-  filePath
-}) {
+const originalNodeEnv = "production";
+function stringifyFileScope({ packageName, filePath }) {
   return packageName ? `${filePath}$$$${packageName}` : filePath;
 }
 function parseFileScope(serialisedFileScope) {
-  const [filePath, packageName] = serialisedFileScope.split('$$$');
+  const [filePath, packageName] = serialisedFileScope.split("$$$");
   return {
     filePath,
-    packageName
+    packageName,
   };
 }
 async function processVanillaFile({
   source,
   filePath,
   outputCss = true,
-  identOption = 'short' ,
-  serializeVirtualCssPath
+  identOption = "short",
+  serializeVirtualCssPath,
 }) {
   const cssByFileScope = new Map();
   const localClassNames = new Set();
@@ -102,24 +113,28 @@ async function processVanillaFile({
       if (outputCss) {
         var _cssByFileScope$get;
         const serialisedFileScope = stringifyFileScope(fileScope);
-        const fileScopeCss = (_cssByFileScope$get = cssByFileScope.get(serialisedFileScope)) !== null && _cssByFileScope$get !== void 0 ? _cssByFileScope$get : [];
+        const fileScopeCss =
+          (_cssByFileScope$get = cssByFileScope.get(serialisedFileScope)) !==
+            null && _cssByFileScope$get !== void 0
+            ? _cssByFileScope$get
+            : [];
         fileScopeCss.push(css);
         cssByFileScope.set(serialisedFileScope, fileScopeCss);
       }
     },
-    registerClassName: className => {
+    registerClassName: (className) => {
       localClassNames.add(className);
     },
-    registerComposition: composedClassList => {
+    registerComposition: (composedClassList) => {
       composedClassLists.push(composedClassList);
     },
-    markCompositionUsed: identifier => {
+    markCompositionUsed: (identifier) => {
       usedCompositions.add(identifier);
     },
     onEndFileScope: () => {},
-    getIdentOption: () => identOption
+    getIdentOption: () => identOption,
   };
-  const currentNodeEnv =         "production";
+  const currentNodeEnv = "production";
 
   // Vite sometimes modifies NODE_ENV which causes different versions (e.g. dev/prod) of vanilla packages to be loaded
   // This can cause CSS to be bound to the wrong instance, resulting in no CSS output
@@ -129,29 +144,36 @@ async function processVanillaFile({
     require('@vanilla-extract/css/adapter').setAdapter(__adapter__);
     ${source}
   `;
-  const evalResult = evalCode__default["default"](adapterBoundSource, filePath, {
-    console,
-    process,
-    __adapter__: cssAdapter
-  }, true);
+  const evalResult = evalCode__default["default"](
+    adapterBoundSource,
+    filePath,
+    {
+      console,
+      process,
+      __adapter__: cssAdapter,
+    },
+    true,
+  );
   process.env.NODE_ENV = currentNodeEnv;
   const cssImports = [];
   for (const [serialisedFileScope, fileScopeCss] of cssByFileScope) {
     const fileScope = parseFileScope(serialisedFileScope);
-    const css = transformCss.transformCss({
-      localClassNames: Array.from(localClassNames),
-      composedClassLists,
-      cssObjs: fileScopeCss
-    }).join('\n');
+    const css = transformCss
+      .transformCss({
+        localClassNames: Array.from(localClassNames),
+        composedClassLists,
+        cssObjs: fileScopeCss,
+      })
+      .join("\n");
     const fileName = `${fileScope.filePath}.vanilla.css`;
     let virtualCssFilePath;
     if (serializeVirtualCssPath) {
       const serializedResult = serializeVirtualCssPath({
         fileName,
         fileScope,
-        source: css
+        source: css,
       });
-      if (typeof serializedResult === 'string') {
+      if (typeof serializedResult === "string") {
         virtualCssFilePath = serializedResult;
       } else {
         virtualCssFilePath = await serializedResult;
@@ -165,78 +187,122 @@ async function processVanillaFile({
 
   // We run this code inside eval as jest seems to create a difrerent instance of the adapter file
   // for requires executed within the eval and all CSS can be lost.
-  evalCode__default["default"](`const { removeAdapter } = require('@vanilla-extract/css/adapter');
+  evalCode__default["default"](
+    `const { removeAdapter } = require('@vanilla-extract/css/adapter');
     // Backwards compat with older versions of @vanilla-extract/css
     if (removeAdapter) {
       removeAdapter();
     }
-  `, filePath, {
-    console,
-    process
-  }, true);
-  const unusedCompositions = composedClassLists.filter(({
-    identifier
-  }) => !usedCompositions.has(identifier)).map(({
-    identifier
-  }) => identifier);
-  const unusedCompositionRegex = unusedCompositions.length > 0 ? RegExp(`(${unusedCompositions.join('|')})\\s`, 'g') : null;
+  `,
+    filePath,
+    {
+      console,
+      process,
+    },
+    true,
+  );
+  const unusedCompositions = composedClassLists
+    .filter(({ identifier }) => !usedCompositions.has(identifier))
+    .map(({ identifier }) => identifier);
+  const unusedCompositionRegex =
+    unusedCompositions.length > 0
+      ? RegExp(`(${unusedCompositions.join("|")})\\s`, "g")
+      : null;
   return serializeVanillaModule(cssImports, evalResult, unusedCompositionRegex);
 }
-function stringifyExports(functionSerializationImports, value, unusedCompositionRegex, key, exportLookup, exportDependencyGraph) {
-  return javascriptStringify.stringify(value, (value, _indent, next) => {
-    const valueType = typeof value;
-    if (valueType === 'boolean' || valueType === 'number' || valueType === 'undefined' || value === null) {
-      return next(value);
-    }
-    if (Array.isArray(value) || isPlainObject__default["default"](value)) {
-      const reusedExport = exportLookup.get(value);
-      if (reusedExport && reusedExport !== key) {
-        exportDependencyGraph.addDependency(key, reusedExport);
-        return reusedExport;
+function stringifyExports(
+  functionSerializationImports,
+  value,
+  unusedCompositionRegex,
+  key,
+  exportLookup,
+  exportDependencyGraph,
+) {
+  return javascriptStringify.stringify(
+    value,
+    (value, _indent, next) => {
+      const valueType = typeof value;
+      if (
+        valueType === "boolean" ||
+        valueType === "number" ||
+        valueType === "undefined" ||
+        value === null
+      ) {
+        return next(value);
       }
-      return next(value);
-    }
-    if (Symbol.toStringTag in Object(value)) {
-      const {
-        [Symbol.toStringTag]: _tag,
-        ...valueWithoutTag
-      } = value;
-      return next(valueWithoutTag);
-    }
-    if (valueType === 'string') {
-      return next(unusedCompositionRegex ? value.replace(unusedCompositionRegex, '') : value);
-    }
-    if (valueType === 'function' && (value.__function_serializer__ || value.__recipe__)) {
-      const {
-        importPath,
-        importName,
-        args
-      } = value.__function_serializer__ || value.__recipe__;
-      if (typeof importPath !== 'string' || typeof importName !== 'string' || !Array.isArray(args)) {
-        throw new Error('Invalid function serialization params');
+      if (Array.isArray(value) || isPlainObject__default["default"](value)) {
+        const reusedExport = exportLookup.get(value);
+        if (reusedExport && reusedExport !== key) {
+          exportDependencyGraph.addDependency(key, reusedExport);
+          return reusedExport;
+        }
+        return next(value);
       }
-      try {
-        const hashedImportName = `_${hash(`${importName}${importPath}`).slice(0, 5)}`;
-        functionSerializationImports.add(`import { ${importName} as ${hashedImportName} } from '${importPath}';`);
-        return `${hashedImportName}(${args.map(arg => stringifyExports(functionSerializationImports, arg, unusedCompositionRegex, key, exportLookup, exportDependencyGraph)).join(',')})`;
-      } catch (err) {
-        console.error(err);
-        throw new Error('Invalid function serialization params');
+      if (Symbol.toStringTag in Object(value)) {
+        const { [Symbol.toStringTag]: _tag, ...valueWithoutTag } = value;
+        return next(valueWithoutTag);
       }
-    }
-    throw new Error(outdent__default["default"]`
+      if (valueType === "string") {
+        return next(
+          unusedCompositionRegex
+            ? value.replace(unusedCompositionRegex, "")
+            : value,
+        );
+      }
+      if (
+        valueType === "function" &&
+        (value.__function_serializer__ || value.__recipe__)
+      ) {
+        const { importPath, importName, args } =
+          value.__function_serializer__ || value.__recipe__;
+        if (
+          typeof importPath !== "string" ||
+          typeof importName !== "string" ||
+          !Array.isArray(args)
+        ) {
+          throw new Error("Invalid function serialization params");
+        }
+        try {
+          const hashedImportName = `_${hash(`${importName}${importPath}`).slice(
+            0,
+            5,
+          )}`;
+          functionSerializationImports.add(
+            `import { ${importName} as ${hashedImportName} } from '${importPath}';`,
+          );
+          return `${hashedImportName}(${args
+            .map((arg) =>
+              stringifyExports(
+                functionSerializationImports,
+                arg,
+                unusedCompositionRegex,
+                key,
+                exportLookup,
+                exportDependencyGraph,
+              ),
+            )
+            .join(",")})`;
+        } catch (err) {
+          console.error(err);
+          throw new Error("Invalid function serialization params");
+        }
+      }
+      throw new Error(outdent__default["default"]`
         Invalid exports.
 
         You can only export plain objects, arrays, strings, numbers and null/undefined.
       `);
-  }, 0, {
-    references: true,
-    // Allow circular references
-    maxDepth: Infinity,
-    maxValues: Infinity
-  });
+    },
+    0,
+    {
+      references: true,
+      // Allow circular references
+      maxDepth: Infinity,
+      maxValues: Infinity,
+    },
+  );
 }
-const defaultExportName = '__default__';
+const defaultExportName = "__default__";
 class DependencyGraph {
   constructor() {
     this.graph = new Map();
@@ -260,7 +326,11 @@ class DependencyGraph {
   dependsOn(key, dependency) {
     const dependencies = this.graph.get(key);
     if (dependencies) {
-      if (dependencies !== null && dependencies !== void 0 && dependencies.has(dependency)) {
+      if (
+        dependencies !== null &&
+        dependencies !== void 0 &&
+        dependencies.has(dependency)
+      ) {
         return true;
       }
       for (const [dep] of dependencies.entries()) {
@@ -274,52 +344,74 @@ class DependencyGraph {
 }
 function serializeVanillaModule(cssImports, exports, unusedCompositionRegex) {
   const functionSerializationImports = new Set();
-  const exportLookup = new Map(Object.entries(exports).map(([key, value]) => [value, key === 'default' ? defaultExportName : key]));
+  const exportLookup = new Map(
+    Object.entries(exports).map(([key, value]) => [
+      value,
+      key === "default" ? defaultExportName : key,
+    ]),
+  );
   const exportDependencyGraph = new DependencyGraph();
   const moduleExports = Object.entries(exports).map(([key, value]) => {
-    const serializedExport = stringifyExports(functionSerializationImports, value, unusedCompositionRegex, key === 'default' ? defaultExportName : key, exportLookup, exportDependencyGraph);
-    if (key === 'default') {
-      return [defaultExportName, [`var ${defaultExportName} = ${serializedExport};`, `export default ${defaultExportName};`].join('\n')];
+    const serializedExport = stringifyExports(
+      functionSerializationImports,
+      value,
+      unusedCompositionRegex,
+      key === "default" ? defaultExportName : key,
+      exportLookup,
+      exportDependencyGraph,
+    );
+    if (key === "default") {
+      return [
+        defaultExportName,
+        [
+          `var ${defaultExportName} = ${serializedExport};`,
+          `export default ${defaultExportName};`,
+        ].join("\n"),
+      ];
     }
     return [key, `export var ${key} = ${serializedExport};`];
   });
-  const sortedModuleExports = moduleExports.sort(([key1], [key2]) => {
-    if (exportDependencyGraph.dependsOn(key1, key2)) {
-      return 1;
-    }
-    if (exportDependencyGraph.dependsOn(key2, key1)) {
-      return -1;
-    }
-    return 0;
-  }).map(([, s]) => s);
-  const outputCode = [...cssImports, ...functionSerializationImports, ...sortedModuleExports];
-  return outputCode.join('\n');
+  const sortedModuleExports = moduleExports
+    .sort(([key1], [key2]) => {
+      if (exportDependencyGraph.dependsOn(key1, key2)) {
+        return 1;
+      }
+      if (exportDependencyGraph.dependsOn(key2, key1)) {
+        return -1;
+      }
+      return 0;
+    })
+    .map(([, s]) => s);
+  const outputCode = [
+    ...cssImports,
+    ...functionSerializationImports,
+    ...sortedModuleExports,
+  ];
+  return outputCode.join("\n");
 }
 
 async function getSourceFromVirtualCssFile(id) {
   const match = id.match(/^(?<fileName>.*)\?source=(?<source>.*)$/);
   if (!match || !match.groups) {
-    throw new Error('No source in vanilla CSS file');
+    throw new Error("No source in vanilla CSS file");
   }
   const source = await deserializeCss(match.groups.source);
   return {
     fileName: match.groups.fileName,
-    source
+    source,
   };
 }
 
 function getClosestPackageInfo(directory) {
-  const packageJsonPath = findUp__default["default"].sync('package.json', {
-    cwd: directory
+  const packageJsonPath = findUp__default["default"].sync("package.json", {
+    cwd: directory,
   });
   if (packageJsonPath) {
-    const {
-      name
-    } = require(packageJsonPath);
+    const { name } = require(packageJsonPath);
     return {
       name,
       path: packageJsonPath,
-      dirname: path__default["default"].dirname(packageJsonPath)
+      dirname: path__default["default"].dirname(packageJsonPath),
     };
   }
 }
@@ -332,10 +424,14 @@ function getPackageInfo(cwd) {
   }
   let packageInfo = getClosestPackageInfo(resolvedCwd);
   while (packageInfo && !packageInfo.name) {
-    packageInfo = getClosestPackageInfo(path__default["default"].resolve(packageInfo.dirname, '..'));
+    packageInfo = getClosestPackageInfo(
+      path__default["default"].resolve(packageInfo.dirname, ".."),
+    );
   }
   if (!packageInfo || !packageInfo.name) {
-    throw new Error(`Couldn't find parent package.json with a name field from '${resolvedCwd}'`);
+    throw new Error(
+      `Couldn't find parent package.json with a name field from '${resolvedCwd}'`,
+    );
   }
   packageInfoCache.set(resolvedCwd, packageInfo);
   return packageInfo;
@@ -351,23 +447,29 @@ function addFileScope({
   filePath,
   rootPath,
   packageName,
-  globalAdapterIdentifier
+  globalAdapterIdentifier,
 }) {
   // Encode windows file paths as posix
-  const normalizedPath = path.posix.join(...path.relative(rootPath, filePath).split(path.sep));
-  if (source.indexOf('@vanilla-extract/css/fileScope') > -1) {
-    return source.replace(/setFileScope\(((\n|.)*?)\)/, `setFileScope("${normalizedPath}", "${packageName}")`);
+  const normalizedPath = path.posix.join(
+    ...path.relative(rootPath, filePath).split(path.sep),
+  );
+  if (source.indexOf("@vanilla-extract/css/fileScope") > -1) {
+    return source.replace(
+      /setFileScope\(((\n|.)*?)\)/,
+      `setFileScope("${normalizedPath}", "${packageName}")`,
+    );
   }
-  const {
-    hasESM,
-    isMixed
-  } = mlly.detectSyntax(source);
+  const { hasESM, isMixed } = mlly.detectSyntax(source);
   if (hasESM && !isMixed) {
-    const setAdapterSnippet = globalAdapterIdentifier ? `
+    const setAdapterSnippet = globalAdapterIdentifier
+      ? `
         import * as __vanilla_css_adapter__ from "@vanilla-extract/css/adapter";
         __vanilla_css_adapter__.setAdapter(${globalAdapterIdentifier});
-      ` : '';
-    const removeAdapterSnippet = setAdapterSnippet ? '__vanilla_css_adapter__.removeAdapter();' : '';
+      `
+      : "";
+    const removeAdapterSnippet = setAdapterSnippet
+      ? "__vanilla_css_adapter__.removeAdapter();"
+      : "";
     return `
       ${setAdapterSnippet}
       import { setFileScope, endFileScope } from "@vanilla-extract/css/fileScope";
@@ -377,11 +479,15 @@ function addFileScope({
       ${removeAdapterSnippet}
     `;
   }
-  const setAdapterSnippet = globalAdapterIdentifier ? `
+  const setAdapterSnippet = globalAdapterIdentifier
+    ? `
       const __vanilla_css_adapter__ = require("@vanilla-extract/css/adapter");
       __vanilla_css_adapter__.setAdapter(${globalAdapterIdentifier});
-    ` : '';
-  const removeAdapterSnippet = setAdapterSnippet ? '__vanilla_css_adapter__.removeAdapter();' : '';
+    `
+    : "";
+  const removeAdapterSnippet = setAdapterSnippet
+    ? "__vanilla_css_adapter__.removeAdapter();"
+    : "";
   return `
     ${setAdapterSnippet}
     const __vanilla_filescope__ = require("@vanilla-extract/css/fileScope");
@@ -397,19 +503,22 @@ const transformSync = ({
   filePath,
   rootPath,
   packageName,
-  identOption
+  identOption,
 }) => {
   let code = source;
-  if (identOption === 'debug') {
+  if (identOption === "debug") {
     const result = babel__namespace.transformSync(source, {
       filename: filePath,
       cwd: rootPath,
-      plugins: [vanillaBabelPlugin__default["default"], typescriptSyntax__default["default"]],
+      plugins: [
+        vanillaBabelPlugin__default["default"],
+        typescriptSyntax__default["default"],
+      ],
       configFile: false,
-      babelrc: false
+      babelrc: false,
     });
     if (!result || result.code == null) {
-      throw new Error('Error adding debug IDs');
+      throw new Error("Error adding debug IDs");
     }
     code = result.code;
   }
@@ -417,7 +526,7 @@ const transformSync = ({
     source: code,
     filePath,
     rootPath,
-    packageName
+    packageName,
   });
 };
 const transform = async ({
@@ -426,19 +535,22 @@ const transform = async ({
   rootPath,
   packageName,
   identOption,
-  globalAdapterIdentifier
+  globalAdapterIdentifier,
 }) => {
   let code = source;
-  if (identOption === 'debug') {
+  if (identOption === "debug") {
     const result = await babel__namespace.transformAsync(source, {
       filename: filePath,
       cwd: rootPath,
-      plugins: [vanillaBabelPlugin__default["default"], typescriptSyntax__default["default"]],
+      plugins: [
+        vanillaBabelPlugin__default["default"],
+        typescriptSyntax__default["default"],
+      ],
       configFile: false,
-      babelrc: false
+      babelrc: false,
     });
     if (!result || result.code == null) {
-      throw new Error('Error adding debug IDs');
+      throw new Error("Error adding debug IDs");
     }
     code = result.code;
   }
@@ -447,69 +559,99 @@ const transform = async ({
     filePath,
     rootPath,
     packageName,
-    globalAdapterIdentifier
+    globalAdapterIdentifier,
   });
 };
 
-const vanillaExtractTransformPlugin = ({
-  identOption
-}) => ({
-  name: 'vanilla-extract-filescope',
+const vanillaExtractTransformPlugin = ({ identOption }) => ({
+  name: "vanilla-extract-filescope",
   setup(build) {
     const packageInfo = getPackageInfo(build.initialOptions.absWorkingDir);
-    build.onLoad({
-      filter: cssFileFilter
-    }, async ({
-      path: path$1
-    }) => {
-      const originalSource = await fs.promises.readFile(path$1, 'utf-8');
-      const source = await transform({
-        source: originalSource,
-        filePath: path$1,
-        rootPath: build.initialOptions.absWorkingDir,
-        packageName: packageInfo.name,
-        identOption: identOption !== null && identOption !== void 0 ? identOption : build.initialOptions.minify ? 'short' : 'debug'
-      });
-      return {
-        contents: source,
-        loader: path$1.match(/\.(ts|tsx)$/i) ? 'ts' : undefined,
-        resolveDir: path.dirname(path$1)
-      };
-    });
-  }
+    build.onLoad(
+      {
+        filter: cssFileFilter,
+      },
+      async ({ path: path$1 }) => {
+        const originalSource = await fs.promises.readFile(path$1, "utf-8");
+        const source = await transform({
+          source: originalSource,
+          filePath: path$1,
+          rootPath: build.initialOptions.absWorkingDir,
+          packageName: packageInfo.name,
+          identOption:
+            identOption !== null && identOption !== void 0
+              ? identOption
+              : build.initialOptions.minify
+              ? "short"
+              : "debug",
+        });
+        return {
+          contents: source,
+          loader: path$1.match(/\.(ts|tsx)$/i) ? "ts" : undefined,
+          resolveDir: path.dirname(path$1),
+        };
+      },
+    );
+  },
 });
 async function compile({
   filePath,
   identOption,
   cwd = process.cwd(),
-  esbuildOptions
+  esbuildOptions,
 }) {
   var _esbuildOptions$exter, _esbuildOptions$plugi;
   const result = await esbuild.build({
     entryPoints: [filePath],
     metafile: true,
     bundle: true,
-    external: ['@vanilla-extract', ...((_esbuildOptions$exter = esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.external) !== null && _esbuildOptions$exter !== void 0 ? _esbuildOptions$exter : [])],
-    platform: 'node',
+    external: [
+      "@vanilla-extract",
+      ...((_esbuildOptions$exter =
+        esbuildOptions === null || esbuildOptions === void 0
+          ? void 0
+          : esbuildOptions.external) !== null &&
+      _esbuildOptions$exter !== void 0
+        ? _esbuildOptions$exter
+        : []),
+    ],
+    platform: "node",
     write: false,
-    plugins: [vanillaExtractTransformPlugin({
-      identOption
-    }), ...((_esbuildOptions$plugi = esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.plugins) !== null && _esbuildOptions$plugi !== void 0 ? _esbuildOptions$plugi : [])],
+    plugins: [
+      vanillaExtractTransformPlugin({
+        identOption,
+      }),
+      ...((_esbuildOptions$plugi =
+        esbuildOptions === null || esbuildOptions === void 0
+          ? void 0
+          : esbuildOptions.plugins) !== null && _esbuildOptions$plugi !== void 0
+        ? _esbuildOptions$plugi
+        : []),
+    ],
     absWorkingDir: cwd,
-    loader: esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.loader,
-    define: esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.define,
-    tsconfig: esbuildOptions === null || esbuildOptions === void 0 ? void 0 : esbuildOptions.tsconfig
+    loader:
+      esbuildOptions === null || esbuildOptions === void 0
+        ? void 0
+        : esbuildOptions.loader,
+    define:
+      esbuildOptions === null || esbuildOptions === void 0
+        ? void 0
+        : esbuildOptions.define,
+    tsconfig:
+      esbuildOptions === null || esbuildOptions === void 0
+        ? void 0
+        : esbuildOptions.tsconfig,
   });
-  const {
-    outputFiles,
-    metafile
-  } = result;
+  const { outputFiles, metafile } = result;
   if (!outputFiles || outputFiles.length !== 1) {
-    throw new Error('Invalid child compilation');
+    throw new Error("Invalid child compilation");
   }
   return {
     source: outputFiles[0].text,
-    watchFiles: Object.keys((metafile === null || metafile === void 0 ? void 0 : metafile.inputs) || {}).map(filePath => path.join(cwd, filePath))
+    watchFiles: Object.keys(
+      (metafile === null || metafile === void 0 ? void 0 : metafile.inputs) ||
+        {},
+    ).map((filePath) => path.join(cwd, filePath)),
   };
 }
 
@@ -543,7 +685,7 @@ async function processQueue() {
   await fn();
 }
 
-const globalAdapterIdentifier = '__vanilla_globalCssAdapter__';
+const globalAdapterIdentifier = "__vanilla_globalCssAdapter__";
 const scanModule = (entryModule, root) => {
   const queue = [entryModule];
   const cssDeps = new Set();
@@ -563,72 +705,77 @@ const scanModule = (entryModule, root) => {
   const [head, ...tail] = cssDeps;
   return {
     cssDeps: [...tail, head],
-    watchFiles
+    watchFiles,
   };
 };
 
 // We lazily load this utility from Vite
 let normalizeModuleId;
-const createViteServer = async ({
-  root,
-  identifiers,
-  vitePlugins = []
-}) => {
+const createViteServer = async ({ root, identifiers, vitePlugins = [] }) => {
   const pkg = getPackageInfo(root);
-  const vite = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('vite')); });
+  const vite = await Promise.resolve().then(function () {
+    return /*#__PURE__*/ _interopNamespace(require("vite"));
+  });
   normalizeModuleId = vite.normalizePath;
   const server = await vite.createServer({
+    configFile: false,
     root,
     server: {
-      hmr: false
+      hmr: false,
     },
-    logLevel: 'silent',
+    logLevel: "silent",
     optimizeDeps: {
-      disabled: true
+      disabled: true,
     },
     ssr: {
-      noExternal: true
+      noExternal: true,
     },
-    plugins: [{
-      name: 'vanilla-extract-externalize',
-      enforce: 'pre',
-      async resolveId(source, importer) {
-        if (source.startsWith('@vanilla-extract/')) {
-          const result = await this.resolve(source, importer, {
-            skipSelf: true
-          });
-          return result ? {
-            ...result,
-            external: true
-          } : null;
-        }
-      }
-    }, {
-      name: 'vanilla-extract-transform',
-      async transform(code, id) {
-        if (cssFileFilter.test(id)) {
-          const filescopedCode = await transform({
-            source: code,
-            rootPath: root,
-            filePath: id,
-            packageName: pkg.name,
-            identOption: identifiers,
-            globalAdapterIdentifier
-          });
-          return filescopedCode;
-        }
-      }
-    }, ...vitePlugins]
+    plugins: [
+      {
+        name: "vanilla-extract-externalize",
+        enforce: "pre",
+        async resolveId(source, importer) {
+          if (source.startsWith("@vanilla-extract/")) {
+            const result = await this.resolve(source, importer, {
+              skipSelf: true,
+            });
+            return result
+              ? {
+                  ...result,
+                  external: true,
+                }
+              : null;
+          }
+        },
+      },
+      {
+        name: "vanilla-extract-transform",
+        async transform(code, id) {
+          if (cssFileFilter.test(id)) {
+            const filescopedCode = await transform({
+              source: code,
+              rootPath: root,
+              filePath: id,
+              packageName: pkg.name,
+              identOption: identifiers,
+              globalAdapterIdentifier,
+            });
+            return filescopedCode;
+          }
+        },
+      },
+      ...vitePlugins,
+    ],
   });
 
   // this is need to initialize the plugins
   await server.pluginContainer.buildStart({});
-  const {
-    ViteNodeRunner
-  } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('vite-node/client')); });
-  const {
-    ViteNodeServer
-  } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('vite-node/server')); });
+  const { ViteNodeRunner } = await Promise.resolve().then(function () {
+    return /*#__PURE__*/ _interopNamespace(require("vite-node/client"));
+  });
+  const { ViteNodeServer } = await Promise.resolve().then(function () {
+    return /*#__PURE__*/ _interopNamespace(require("vite-node/server"));
+  });
   const node = new ViteNodeServer(server);
   const runner = new ViteNodeRunner({
     root,
@@ -638,36 +785,33 @@ const createViteServer = async ({
     },
     resolveId(id, importer) {
       return node.resolveId(id, importer);
-    }
+    },
   });
-  server.watcher.on('change', filePath => {
+  server.watcher.on("change", (filePath) => {
     runner.moduleCache.invalidateDepTree([filePath]);
   });
   return {
     server,
-    runner
+    runner,
   };
 };
 const createCompiler = ({
   root,
-  identifiers = 'debug',
-  cssImportSpecifier = filePath => filePath + '.vanilla.css',
-  vitePlugins
+  identifiers = "debug",
+  cssImportSpecifier = (filePath) => filePath + ".vanilla.css",
+  vitePlugins,
 }) => {
   let originalPrepareContext;
   const vitePromise = createViteServer({
     root,
     identifiers,
-    vitePlugins
-  }).then(({
-    server,
-    runner
-  }) => {
+    vitePlugins,
+  }).then(({ server, runner }) => {
     // Store the original method so we can monkey patch it on demand
     originalPrepareContext = runner.prepareContext;
     return {
       server,
-      runner
+      runner,
     };
   });
   const cssCache = new Map();
@@ -676,20 +820,30 @@ const createCompiler = ({
   return {
     async processVanillaFile(filePath, options = {}) {
       var _options$outputCss;
-      const {
-        server,
-        runner
-      } = await vitePromise;
-      filePath = path.isAbsolute(filePath) ? filePath : path.join(root, filePath);
-      const outputCss = (_options$outputCss = options.outputCss) !== null && _options$outputCss !== void 0 ? _options$outputCss : true;
+      const { server, runner } = await vitePromise;
+      filePath = path.isAbsolute(filePath)
+        ? filePath
+        : path.join(root, filePath);
+      const outputCss =
+        (_options$outputCss = options.outputCss) !== null &&
+        _options$outputCss !== void 0
+          ? _options$outputCss
+          : true;
       const cacheKey = Object.entries({
         filePath,
-        outputCss
-      }).map(entry => entry.join('=')).join('|');
+        outputCss,
+      })
+        .map((entry) => entry.join("="))
+        .join("|");
       const cachedFile = processVanillaFileCache.get(cacheKey);
       if (cachedFile) {
         const moduleNode = server.moduleGraph.getModuleById(filePath);
-        if (cachedFile.lastInvalidationTimestamp === (moduleNode === null || moduleNode === void 0 ? void 0 : moduleNode.lastInvalidationTimestamp)) {
+        if (
+          cachedFile.lastInvalidationTimestamp ===
+          (moduleNode === null || moduleNode === void 0
+            ? void 0
+            : moduleNode.lastInvalidationTimestamp)
+        ) {
           return cachedFile.result;
         }
       }
@@ -698,41 +852,51 @@ const createCompiler = ({
       const composedClassLists = [];
       const cssAdapter = {
         getIdentOption: () => identifiers,
-        onBeginFileScope: fileScope => {
+        onBeginFileScope: (fileScope) => {
           // Before evaluating a file, reset the cache for it
           const moduleId = normalizeModuleId(fileScope.filePath);
           cssByModuleId.set(moduleId, []);
           classRegistrationsByModuleId.set(moduleId, {
             localClassNames: new Set(),
-            composedClassLists: []
+            composedClassLists: [],
           });
         },
-        onEndFileScope: ({
-          filePath
-        }) => {
+        onEndFileScope: ({ filePath }) => {
           var _cssByModuleId$get;
           // For backwards compatibility, ensure the cache is populated even if
           // a file didn't contain any CSS. This is to ensure that the only
           // error messages shown in older versions are the ones below.
           const moduleId = normalizeModuleId(filePath);
-          const cssObjs = (_cssByModuleId$get = cssByModuleId.get(moduleId)) !== null && _cssByModuleId$get !== void 0 ? _cssByModuleId$get : [];
+          const cssObjs =
+            (_cssByModuleId$get = cssByModuleId.get(moduleId)) !== null &&
+            _cssByModuleId$get !== void 0
+              ? _cssByModuleId$get
+              : [];
           cssByModuleId.set(moduleId, cssObjs);
         },
         registerClassName: (className, fileScope) => {
           if (!fileScope) {
-            throw new Error('Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.');
+            throw new Error(
+              "Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.",
+            );
           }
           localClassNames.add(className);
           const moduleId = normalizeModuleId(fileScope.filePath);
-          classRegistrationsByModuleId.get(moduleId).localClassNames.add(className);
+          classRegistrationsByModuleId
+            .get(moduleId)
+            .localClassNames.add(className);
         },
         registerComposition: (composedClassList, fileScope) => {
           if (!fileScope) {
-            throw new Error('Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.');
+            throw new Error(
+              "Your version of @vanilla-extract/css must be at least v1.10.0. Please update to a compatible version.",
+            );
           }
           composedClassLists.push(composedClassList);
           const moduleId = normalizeModuleId(fileScope.filePath);
-          classRegistrationsByModuleId.get(moduleId).composedClassLists.push(composedClassList);
+          classRegistrationsByModuleId
+            .get(moduleId)
+            .composedClassLists.push(composedClassList);
         },
         markCompositionUsed: () => {
           // This compiler currently retains all composition classes
@@ -740,86 +904,102 @@ const createCompiler = ({
         appendCss: (css, fileScope) => {
           var _cssByModuleId$get2;
           const moduleId = normalizeModuleId(fileScope.filePath);
-          const cssObjs = (_cssByModuleId$get2 = cssByModuleId.get(moduleId)) !== null && _cssByModuleId$get2 !== void 0 ? _cssByModuleId$get2 : [];
+          const cssObjs =
+            (_cssByModuleId$get2 = cssByModuleId.get(moduleId)) !== null &&
+            _cssByModuleId$get2 !== void 0
+              ? _cssByModuleId$get2
+              : [];
           cssObjs.push(css);
           cssByModuleId.set(moduleId, cssObjs);
-        }
+        },
       };
-      const {
-        fileExports,
-        cssImports,
-        watchFiles,
-        lastInvalidationTimestamp
-      } = await lock(async () => {
-        // Monkey patch the prepareContext method to inject the adapter
-        runner.prepareContext = function (...args) {
-          return {
-            ...originalPrepareContext.apply(this, args),
-            [globalAdapterIdentifier]: cssAdapter
+      const { fileExports, cssImports, watchFiles, lastInvalidationTimestamp } =
+        await lock(async () => {
+          // Monkey patch the prepareContext method to inject the adapter
+          runner.prepareContext = function (...args) {
+            return {
+              ...originalPrepareContext.apply(this, args),
+              [globalAdapterIdentifier]: cssAdapter,
+            };
           };
-        };
-        const fileExports = await runner.executeFile(filePath);
-        const moduleId = normalizeModuleId(filePath);
-        const moduleNode = server.moduleGraph.getModuleById(moduleId);
-        if (!moduleNode) {
-          throw new Error(`Can't find ModuleNode for ${filePath}`);
-        }
-        const cssImports = [];
-        const {
-          cssDeps,
-          watchFiles
-        } = scanModule(moduleNode, root);
-        for (const cssDep of cssDeps) {
-          const cssDepModuleId = normalizeModuleId(cssDep);
-          const cssObjs = cssByModuleId.get(cssDepModuleId);
-          const cachedCss = cssCache.get(cssDepModuleId);
-          const cachedClassRegistrations = classRegistrationsByModuleId.get(cssDepModuleId);
-          if (!cssObjs && !cachedCss && !cachedClassRegistrations) {
-            continue;
-          }
-          if (cssObjs) {
-            const css = transformCss.transformCss({
-              localClassNames: Array.from(localClassNames),
-              composedClassLists,
-              cssObjs
-            }).join('\n');
-            cssCache.set(cssDepModuleId, {
-              css
-            });
-          } else if (cachedClassRegistrations) {
-            cachedClassRegistrations.localClassNames.forEach(localClassName => {
-              localClassNames.add(localClassName);
-            });
-            composedClassLists.push(...cachedClassRegistrations.composedClassLists);
+          const fileExports = await runner.executeFile(filePath);
+          const moduleId = normalizeModuleId(filePath);
+          const moduleNode = server.moduleGraph.getModuleById(moduleId);
+          if (!moduleNode) {
+            throw new Error(`Can't find ModuleNode for ${filePath}`);
           }
-          if (cssObjs || cachedCss !== null && cachedCss !== void 0 && cachedCss.css) {
-            cssImports.push(`import '${cssImportSpecifier(cssDepModuleId)}';`);
+          const cssImports = [];
+          const { cssDeps, watchFiles } = scanModule(moduleNode, root);
+          for (const cssDep of cssDeps) {
+            const cssDepModuleId = normalizeModuleId(cssDep);
+            const cssObjs = cssByModuleId.get(cssDepModuleId);
+            const cachedCss = cssCache.get(cssDepModuleId);
+            const cachedClassRegistrations =
+              classRegistrationsByModuleId.get(cssDepModuleId);
+            if (!cssObjs && !cachedCss && !cachedClassRegistrations) {
+              continue;
+            }
+            if (cssObjs) {
+              const css = transformCss
+                .transformCss({
+                  localClassNames: Array.from(localClassNames),
+                  composedClassLists,
+                  cssObjs,
+                })
+                .join("\n");
+              cssCache.set(cssDepModuleId, {
+                css,
+              });
+            } else if (cachedClassRegistrations) {
+              cachedClassRegistrations.localClassNames.forEach(
+                (localClassName) => {
+                  localClassNames.add(localClassName);
+                },
+              );
+              composedClassLists.push(
+                ...cachedClassRegistrations.composedClassLists,
+              );
+            }
+            if (
+              cssObjs ||
+              (cachedCss !== null && cachedCss !== void 0 && cachedCss.css)
+            ) {
+              cssImports.push(
+                `import '${cssImportSpecifier(cssDepModuleId)}';`,
+              );
+            }
           }
-        }
-        return {
-          fileExports,
-          cssImports: outputCss ? cssImports : [],
-          watchFiles,
-          lastInvalidationTimestamp: moduleNode.lastInvalidationTimestamp
-        };
-      });
+          return {
+            fileExports,
+            cssImports: outputCss ? cssImports : [],
+            watchFiles,
+            lastInvalidationTimestamp: moduleNode.lastInvalidationTimestamp,
+          };
+        });
       const result = {
-        source: serializeVanillaModule(cssImports, fileExports, null // This compiler currently retains all composition classes
+        source: serializeVanillaModule(
+          cssImports,
+          fileExports,
+          null, // This compiler currently retains all composition classes
         ),
 
-        watchFiles
+        watchFiles,
       };
       processVanillaFileCache.set(cacheKey, {
         lastInvalidationTimestamp,
-        result
+        result,
       });
       return result;
     },
     getCssForFile(filePath) {
       if (!normalizeModuleId) {
-        throw new Error(`Compiler is still loading. No CSS for file: ${filePath}`);
+        throw new Error(
+          `Compiler is still loading. No CSS for file: ${filePath}`,
+        );
       }
-      filePath = path.isAbsolute(filePath) ? filePath : path.join(root, filePath);
+      filePath = path.isAbsolute(filePath)
+        ? filePath
+        : path.join(root, filePath);
       const rootRelativePath = path.relative(root, filePath);
       const moduleId = normalizeModuleId(rootRelativePath);
       const result = cssCache.get(moduleId);
@@ -829,15 +1009,13 @@ const createCompiler = ({
       return {
         css: result.css,
         filePath: rootRelativePath,
-        resolveDir: root
+        resolveDir: root,
       };
     },
     async close() {
-      const {
-        server
-      } = await vitePromise;
+      const { server } = await vitePromise;
       await server.close();
-    }
+    },
   };
 };
 
